// todo - using https://unpkg.com/@ionic/docs@6.3.8/core.json
// todo - using https://unpkg.com/@ionic/docs@6.4.2/core.json
// todo - using https://unpkg.com/@ionic/docs@6.5.3/core.json

// using https://unpkg.com/@ionic/docs@6.6.0/core.json
// using https://unpkg.com/@ionic/docs@7.0.2/core.json
// using https://unpkg.com/@ionic/docs@7.0.3/core.json
// using https://unpkg.com/@ionic/docs@8.2.2/core.json

const fs = require("fs");
const https = require("https");
const { promisify } = require("util"); // For converting callbacks to promises

// Convert callback-based functions to promise-based
const writeFileAsync = promisify(fs.writeFile);
const readFileAsync = promisify(fs.readFile);

const kebabize = (str) => {
  return str
    .split("")
    .map((letter, idx) => {
      return letter.toUpperCase() === letter
        ? `${idx !== 0 ? "-" : ""}${letter.toLowerCase()}`
        : letter;
    })
    .join("");
};

function toPascalCase(text) {
  return text.replace(/(^\w|-\w)/g, clearAndUpper);
}

function clearAndUpper(text) {
  return text.replace(/-/, "").toUpperCase();
}

async function doStuff() {
  // load static
  const coreJson = require("./core.json");

  const { components } = coreJson;

  console.log("Component count", components.length);

  let typingOutput = "";
  let baseTemplate = `
  // Generated by scripts/generator.js
  // https://github.com/sveltejs/language-tools/blob/master/docs/preprocessors/typescript.md#im-using-an-attributeevent-on-a-dom-element-and-it-throws-a-type-error

  /* eslint-disable */
  /* tslint:disable */
  import type { HTMLAttributes } from 'svelte/elements';
  import type { AccordionGroupChangeEventDetail, ActionSheetButton, AlertButton, AlertInput, BreadcrumbCollapsedClickEventDetail, CheckboxChangeEventDetail, ComponentProps, DatetimeChangeEventDetail, InputChangeEventDetail, InputInputEventDetail, ItemReorderEventDetail, ModalBreakpointChangeEventDetail, NavComponent, NavComponentWithProps, NavOptions, OverlayEventDetail, PickerButton, PickerColumn, RadioGroupChangeEventDetail, RangeChangeEventDetail, RangeKnobMoveEndEventDetail, RangeKnobMoveStartEventDetail, RefresherEventDetail, RouterEventDetail, ScrollBaseDetail, ScrollDetail, SearchbarChangeEventDetail, SearchbarInputEventDetail, SegmentChangeEventDetail, SelectChangeEventDetail, TextareaChangeEventDetail, TextareaInputEventDetail, ToastButton, ToggleChangeEventDetail, TransitionDoneFn, ViewController } from "@ionic/core";
  import type { DatetimeHighlight, IonicConfig, IonicSafeString } from "@ionic/core";
  import { SvelteComponent } from 'svelte';
  import { DatetimeHighlightStyle } from '@ionic/core/dist/types/components/datetime/datetime-interface';

  export function setupIonicBase(config?: IonicConfig);
  export function registerMenu(menuId: string);
  export function createNavPageFromSvelte(
    component: new (...args: any) => SvelteComponent,
    componentProps: {}
  )

  export { default as IonTabs } from "./components/IonTabs.svelte";
  // export { default as IonTabsLegacy } from "./components/IonTabsLegacy.svelte";
  export { default as IonPage } from "./components/IonPage.svelte";
  export { default as IonNav } from "./components/IonNav.svelte";

  // thank you ChatGPT!
export const navController: {
  canGoBack: (view?: ViewController) => boolean | undefined;
  getActive: () => ViewController | undefined;
  getByIndex: (index: number) => ViewController | undefined;
  getPrevious: (view?: ViewController) => ViewController | undefined;
  insert: <T extends NavComponent>(insertIndex: number, component: T, componentProps?: ComponentProps<T> | null, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  insertPages: (insertIndex: number, insertComponents: NavComponent[] | NavComponentWithProps[], opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  pop: (opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  popTo: (indexOrViewCtrl: number | ViewController, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  popToRoot: (opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  push: <T extends NavComponent>(component: T, componentProps?: ComponentProps<T>, opts?: NavOptions, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  removeIndex: (startIndex: number, removeCount?: number, opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  setPages: (views: NavComponent[] | NavComponentWithProps[], opts?: NavOptions | null, done?: TransitionDoneFn) => Promise<boolean> | undefined;
  setRoot: <T extends NavComponent>(component: T, componentProps?: ComponentProps<T>, opts?: NavOptions, done?: TransitionDoneFn) => Promise<boolean> | undefined;
}

// we overload (modalcontroller and popovercontroller) from ionic-core with same types, so let's mirror these
export {
  modalController, popoverController, actionSheetController,
  alertController,
  loadingController,
  menuController,
  pickerController,
  toastController
} from "@ionic/core";

// platforms
declare const PLATFORMS_MAP: {
  [key: string]: boolean;
};

declare type Platforms = keyof typeof PLATFORMS_MAP;

export function getPlatforms(win?: any): string[];
export function setupPlatforms(win: any);

interface IsPlatformSignature {
  (plt: Platforms): boolean;
  (win: Window, plt: Platforms): boolean;
}
export function isPlatform(
  winOrPlatform: Window | Platforms | undefined,
  platform?: Platforms
): IsPlatformSignature;

export function testUserAgent(win: Window, expr: RegExp);


  // not exported by @ionic/core
  export type NavigationHookResult = boolean | NavigationHookOptions;
  export interface NavigationHookOptions {
    redirect: string;
 }
  export interface HTMLBaseAttributes extends HTMLAttributes<HTMLBaseElement> {
  }

  declare global {

    namespace svelteHTML {

    <COMPONENTTYPES>

      interface IntrinsicElements {
      <COMPONENTDECLARATIONS>
      }
    }
  }
  `;

  //
  // PART 1 - Typings file
  //
  let componentTypes = ``;
  let componentDeclarations = "";

  components
    //  .filter(component => component.tag == 'ion-button')
    .forEach((component) => {
      const { props, events, tag } = component;

      const tagWithoutIon = component.tag.replace("ion-", "");
      const tagAsPascal = toPascalCase(component.tag);

      // pre-amble of this tag
      console.log("Processing ", component.tag, toPascalCase(component.tag));
      componentDeclarations =
        componentDeclarations +
        `'${component.tag}': ${tagAsPascal} & HTMLBaseAttributes; \n`;
      /**
       * ${component.tag}
       * More info: https://ionicframework.com/docs/api/${tagWithoutIon}
       */

      // slots support
      componentTypes = componentTypes + `interface ${tagAsPascal} {\n`; //  extends EventTarget

      // let's dump the props
      // console.log('has props', props);
      props.forEach((prop) => {
        //   "disabled"?: boolean;
        componentTypes =
          componentTypes +
          `
          /**
          * ${prop.docs.replace(/\n/g, " ")}
          * API info: https://ionicframework.com/docs/api/${tagWithoutIon}#${prop.name.toLowerCase()}
          */
          "${kebabize(prop.name)}"?: ${prop.type};
        `;
      });

      // let's dump the events
      // console.log('has props', events);
      events.forEach((event) => {
        //     "on:ionSlideReachEnd"?: () => void;

        const htmlElementType = "HTML" + toPascalCase(tag) + "Element";

        const entryToAdd =
          event.detail !== "void"
            ? `
        /**
        * (event : ${event.detail}) => void :  ${event.docs.replace(/\n/g, " ")}
        */
        "on:${event.event}"?: (event : CustomEvent<${event.detail}> & { target: ${htmlElementType} } ) => void;
      `
            : `
      /**
      * () => void :  ${event.docs.replace(/\n/g, " ")}
      */
      "on:${event.event}"?: () => void;
    `;
        componentTypes = componentTypes + entryToAdd;
      });

      // close definition
      componentTypes = componentTypes + `\n}\n\n`;
    });

  // generate final template
  typingOutput = baseTemplate
    .replace("<COMPONENTTYPES>", componentTypes)
    .replace("<COMPONENTDECLARATIONS>", componentDeclarations);

  // console.log('Typings output', typingOutput)

  // Convert to promise to track completion
  await writeFileAsync("../index.d.ts", typingOutput);
  console.log("Typings file written successfully");

  //
  // PART 2 - Code splitted imports
  //
  // create the module imports
  let allImportsCode = ``;

  // Create an array to store all file write promises
  const fileWritePromises = [];

  components
    // .filter(component => component.tag == 'ion-input')
    .forEach((component) => {
      const { tag } = component;
      const componentCode = `import { defineCustomElement } from '@ionic/core/components/${tag}';\ndefineCustomElement();`;

      allImportsCode =
        allImportsCode + `import 'ionic-svelte/components/${tag}';\n`;

      // Add each file write to our promises array
      fileWritePromises.push(
        writeFileAsync(`../components/${tag}.js`, componentCode),
      );
    });

  // Add the all.js file write to our promises array
  fileWritePromises.push(
    writeFileAsync(`../components/all.js`, allImportsCode),
  );

  // Wait for all file writes to complete
  await Promise.all(fileWritePromises);
  console.log("All component files written successfully");

  return "All operations completed successfully!";
}

function extractVersion(url) {
  const regex = /@(\d+\.\d+\.\d+)/;
  const match = url.match(regex);

  if (match) {
    const version = match[1];
    // console.log(version); // Output: "7.0.3"
    return version;
  } else {
    console.log("No version number found");
    return "ERROR";
  }
}

async function bumpPackageJson(version) {
  const currentDirectory = process.cwd();

  if (currentDirectory.includes("script")) {
    console.log(
      "Current directory contains the word 'script' - that is how we want it",
    );
  } else {
    console.log(
      "Current directory does not contain the word 'script' - aborting",
    );
    process.exit(1);
  }

  const filePath = "../package.json";
  const packageName = "ionic-svelte";

  try {
    const data = await readFileAsync(filePath, "utf-8");

    // make backup
    await writeFileAsync(filePath + ".bak", data, "utf-8");
    console.log(`Backup created of ${filePath}`);

    const packageJson = JSON.parse(data);

    if (packageJson.dependencies && packageJson.dependencies[packageName]) {
      packageJson.dependencies[packageName] = version;
    } else if (
      packageJson.devDependencies &&
      packageJson.devDependencies[packageName]
    ) {
      packageJson.devDependencies[packageName] = version;
    } else {
      console.log(
        `Package ${packageName} not found in dependencies or devDependencies`,
      );
    }

    const updatedPackageJson = JSON.stringify(packageJson, null, 2);

    await writeFileAsync(filePath, updatedPackageJson, "utf-8");
    console.log(
      `Version of package ${packageName} updated to ${version}\n${updatedPackageJson}`,
    );
  } catch (err) {
    console.error("Error updating package.json:", err);
    throw err;
  }
}

async function bumpCreatorPackages(version, fileName) {
  try {
    // Read the contents of the creator.js file
    const data = await readFileAsync(fileName, "utf8");

    // make backup
    await writeFileAsync(fileName + ".bak", data, "utf-8");
    console.log(`Backup created of ${fileName}`);

    // Define the search and replace strings
    const searchStr = "['@ionic/core@";
    const replaceStr = "['@ionic/core@" + version;

    // Use a regular expression to search and replace the desired string
    const regex = new RegExp(`${searchStr}\\d+\\.\\d+\\.\\d+'`, "g");
    const newData = data.replace(regex, replaceStr + "'");

    // Write the updated contents back to the file
    await writeFileAsync(fileName, newData, "utf8");
    console.log(`${fileName} updated successfully!`);
  } catch (err) {
    console.error(`Error updating ${fileName}:`, err);
    throw err;
  }
}

// Convert the download function to use promises
function downloadFile(url) {
  return new Promise((resolve, reject) => {
    const request = https.get(url, (res) => {
      let data = "";

      res.on("data", (chunk) => {
        data += chunk;
      });

      res.on("end", () => {
        resolve(data);
      });

      res.on("error", (err) => {
        reject(err);
      });
    });

    request.on("error", (err) => {
      reject(err);
    });

    // Set a timeout to ensure the request doesn't hang
    request.setTimeout(30000, () => {
      request.destroy();
      reject(new Error("Request timeout"));
    });
  });
}

// Main function to orchestrate the entire process
async function main() {
  const url = "https://unpkg.com/@ionic/docs/core.json";
  const file = "core.json";

  try {
    // First HTTP request to get the redirect
    const initialRequest = https.get(url, async (res) => {
      try {
        if (
          res.statusCode >= 300 &&
          res.statusCode <= 399 &&
          res.headers.location
        ) {
          // Redirect detected
          console.log("Redirect detected:", res.headers.location);
          const version = extractVersion(res.headers.location);
          console.log("Version found:", version);

          // Close the initial request
          initialRequest.destroy();

          // Update package.json
          await bumpPackageJson(version);

          // Optional: Uncomment these if needed
          // await bumpCreatorPackages(version, '../packages/create-capacitor-svelte-app/src/creator.js');
          // await bumpCreatorPackages(version, '../packages/create-ionic-svelte-app/src/creator.js');

          // Download the actual file
          const fileData = await downloadFile(
            "https://unpkg.com" + res.headers.location,
          );
          await writeFileAsync(file, fileData);
          console.log(`File saved as ${file} - length ${fileData.length}`);

          // Process the file
          const result = await doStuff();
          console.log(result);

          // Successfully exit the process
          console.log("All tasks completed successfully. Exiting...");
          process.exit(0);
        } else {
          // No redirect, just download directly
          const fileData = await downloadFile(url);
          await writeFileAsync(file, fileData);
          console.log(`File saved as ${file} - length ${fileData.length}`);

          // Process the file
          const result = await doStuff();
          console.log(result);

          // Successfully exit the process
          console.log("All tasks completed successfully. Exiting...");
          process.exit(0);
        }
      } catch (err) {
        console.error("Error in processing:", err);
        process.exit(1);
      }
    });

    // Handle errors on the initial request
    initialRequest.on("error", (err) => {
      console.error("Error on initial request:", err);
      process.exit(1);
    });

    // Set a timeout for the initial request
    initialRequest.setTimeout(30000, () => {
      initialRequest.destroy();
      console.error("Initial request timeout");
      process.exit(1);
    });
  } catch (err) {
    console.error("Error in main function:", err);
    process.exit(1);
  }
}

// Run the main function
main().catch((err) => {
  console.error("Unhandled error in main:", err);
  process.exit(1);
});
